{"docs/v1/binding-connect":{"titles":{"binding-connect":"Binding - Connect"},"text":"There is another method to retrieve data from the server - with JavaScript on the client-side. I will show the best practices of doing so. Forms are very useful and convenient but do not fit good to events from the client side. That way we have to â€˜connectâ€™ tag. ğŸ“‹ @code { async function userMessage(text, userId){ try { return await sendMessageToUser(text, userId, Session.userId) } catch { return {error: &quot;Can&#x27;t send message - make sure user exists&quot;} } } } &lt;eas-connect server-func=&quot;userMessage&quot; client-func=&quot;sendMessageServer&quot; validate=&quot;1-200,integer&quot;/&gt; &lt;input type=&quot;number&quot; id=&quot;userId&quot; placeholder=&quot;User Id&quot;/&gt; &lt;textarea id=&quot;message&quot; name=&quot;message&quot; placeholder=&quot;Enter your message&quot;&gt;&lt;/textarea&gt; &lt;button onclick=&quot;sendMessage()&quot;&gt;Send Message&lt;/button&gt; &lt;script&gt; const $ = x =&gt; document.querySelector(x); async function sendMessage(){ const sent = await sendMessageServer($(&#x27;#userId&#x27;).value, $(&#x27;#message&#x27;).value) if(sent.error) return alert(&#x27;Error: &#x27; + sent.error); alert(&#x27;Success: &#x27; + sent); } &lt;/script&gt; The response can be any type (JSON, Number, Booleanâ€¦) Validation Error You can also use â€˜error-funcâ€™ and â€˜error-messageâ€™ ğŸ“‹ &lt;eas-connect server-fn=&quot;userMessage&quot; client-fn=&quot;sendMessageServer&quot; validate=&quot;1:200,integer&quot; error-fn=&quot;() =&gt; ({error: &#x27;fields not valid&#x27;})&quot;/&gt; ğŸ“‹ &lt;eas-connect server-fn=&quot;userMessage&quot; client-fn=&quot;sendMessageServer&quot; validate=&quot;1:200,integer&quot; error-msg=&quot;Enter a valid userId and make sure the message is between 1 to 200 characters&quot;/&gt;"},"docs/v1/client-scope":{"titles":{"scoped-script-style":"Scoped Script/Style","bundling":"Bundling","only-in-page-script-style":"Only in page script/style"},"text":"All content inside all script/style tags is bundled into js/css files and imported automatically to the page - meanings any SSR in this tags wanâ€™t work. If you want to prevent that, for example, you need SSR inside the script tag then you can add the â€˜serverâ€™ attribute. Same appends to style tags ğŸ“‹ &lt;script server&gt; const preventFetch = @isFetch &lt;/script&gt; If you have script/style with a changes that depends on the file you need to and the â€˜pageâ€™ attribute This will make sure that script and style will be scoped to the page. ğŸ“‹ &lt;script page&gt; const name = &quot;:name:&quot;; &lt;/script&gt; â€˜:name:â€™ is a â€˜defineâ€™ value"},"docs/v1/examples":{"titles":{"guides":"Guides","examples":"Examples","repositories":"Repositories"},"text":"on build Simple Calculator Simple Gallery WS Chat You can checkout the examples in the Home Page This Website"},"docs/v1/binding-form":{"titles":{"binding-form":"Binding - Form","simple-form":"Simple form","validation":"Validation","validation-types":"Validation Types","simple-types":"Simple Types","complex-validation":"Complex Validation","validation-options":"Validation Options","escape-server-response":"Escape Server Response"},"text":"There are many ways to use a form, in this guild we will focus on best practices ğŸ“‹ @code { if(Post){ if(testLogin(Post.email, Post.password)) return Response.redirect(&#x27;/&#x27;); write(&#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;); } } &lt;form action=&quot;post&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; EAS Framework, provide a better way of doing so ğŸ“‹ @code { function checkLogin(email, password){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;eas-form server-fn=&quot;checkLogin&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/eas-form&gt; Change input order You can change the input order with the â€˜orderâ€™ attribute ğŸ“‹ @code { function checkLogin(password,email){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;eas-form server-fn=&quot;checkLogin&quot; order=&quot;password,email&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/eas-form&gt; We can also add validation as needed ğŸ“‹ @code { function checkLogin(email, password){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;eas-form server-fn=&quot;checkLogin&quot; validate=&quot;email:email,password:6-30&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot; /&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot; /&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/eas-form&gt; The order of the fields in â€˜validateâ€™ is the order of the arguments the â€˜server-fnâ€™ function get A simple way to validate and parse a form data â€˜Regexâ€™ and â€˜Functionâ€™ validation will not parse the form data Number Intger Boolean String Email Name number integer boolean string email Shorthand num int bool text String Length Range Integer Number Range Float Number Range String Enum Number Enum Regex Function Example 6-10 -5..15 -5.2..15.0 string =&gt; cat | dog number =&gt; 1 | 8 /^[a-z]+[0-9]$/ myFunction Comment Between 6 to 10 string length Between -5 to 15 number range Between -5.2 to 15 number range Multiple choice for string Multiple choice for number Can be any Regex instance If none of the previous methods is possible, it will call the function. **The function can be asynchrony** You can use any shorthand in enum Default error message By default, the framework will enable auto-generate error messages in debug mode. You can disable it by setting â€˜error-msg=falseâ€™ OR if you want to them in production set â€˜error-msg=trueâ€™ If you want to disable it globally you can enable the â€œSafeDebugâ€ plugin ğŸ“‹ &lt;eas-form server-fn=&quot;checkLogin&quot; validate=&quot;email:email,password:6-30&quot; error-msg=&quot;false&quot;&gt; &lt;/eas-form&gt; You can also override the auto-generate error message and set the â€˜error-msgâ€™ to be a string ğŸ“‹ &lt;eas-form server-fn=&quot;checkLogin&quot; validate=&quot;email:email,password:6-30&quot; error-msg=&quot;Make sure the email valid and password between 6 to 30 characters&quot;&gt; &lt;/eas-form&gt; Custom error event â€˜error-fnâ€™ attribute contains the name of the function that will be called in case of an error. The function will get the ğŸ“‹ function(message: string, validationType: string (name_of_validation_type) | RegExp | method, validationArguments: []number | []string, value: string | number | boolean): Promise&lt;any&gt; | any Example ğŸ“‹ @code { function thatError(message, type){ return `There is an error in that type:${type}`; } } &lt;eas-form server-fn=&quot;checkLogin&quot; validate=&quot;email:email,password:6-30&quot; error-fn=&quot;thatError&quot;&gt; &lt;/eas-form&gt; To escape HTML message from server-fn, error-msg, error-fn add the â€˜escape-responseâ€™ tag. ğŸ“‹ &lt;eas-form server-fn=&quot;checkLogin&quot; validate=&quot;email:email,password:6-30&quot; error-msg=&quot;This &lt;/p&gt; will not cause an error&quot; escape-response&gt; &lt;/eas-form&gt;"},"docs/v1/client-svelte":{"titles":{"svelte-component":"Svelte Component","ssr":"SSR","sass-type-script":"Sass, TypeScript"},"text":"The JS and CSS will be auto-import to the page All props will copied to the svelte app ğŸ“‹ &lt;eas-svelte file=&quot;./path/to/svelte-file&quot; props={counter: 0, name: &#x27;Cool-Website&#x27;}/&gt; The framework will auto-generate div with id the svelte render as a target. You can prevent that by passing your own selector ğŸ“‹ &lt;eas-svelte file=&quot;./path/to/svelte-file&quot; selector=&quot;#todo&quot;/&gt; You can also only change the id that the framework use for the div. ğŸ“‹ &lt;eas-svelte file=&quot;./path/to/svelte-file&quot; id=&quot;#todo&quot;/&gt; Simply add â€˜SSRâ€™ attribute, the framework will do the rest. You canâ€™t use â€˜selectorâ€™ cause there need to be SSR writing to the page, but you can change the id. ğŸ“‹ &lt;eas-svelte file=&quot;./path/to/svelte-file&quot; ssr/&gt; If you wondering, yes all of that is supported inside of the svelte file with the framework. On debug mode source map will be inserted automatically ğŸ“‹ &lt;style lang=sass&gt; If you use TypeScript with svelte import all types via â€˜import typeâ€™, so esbuild will know what to remove. This is necessary only on svelte because how svelte works ğŸ“‹ &lt;script lang=ts&gt; @import type {coolType} from &#x27;./location.ts&#x27; const beType: coolType = {attr1: 1, attr2: 2}; &lt;/script&gt;"},"docs/v1/cli-commands":{"titles":{"cli-commends":"CLI Commends"},"text":""},"docs/v1/client-ts":{"titles":{"client-type-script":"Client TypeScript","ssr-block":"SSR Block","as-static-file":"As Static File","with-compile-runtime":"With Compile Runtime"},"text":"You can use TypeScript freely on any SSR block &amp; as separated file When you import TypeScript it automatically transpile into regular JavaScript ğŸ“‹ &lt;script lang=ts type=module&gt; import {capitalize} from &#x27;/scripts/capitalize.ts&#x27; let name: string; while(!name){ name = capitalize(prompt(&#x27;Enter Name&#x27;)); } &lt;/script&gt; WWW/scripts/getName.ts ğŸ“‹ let name: string; while(!name){ name = prompt(&#x27;Enter Name&#x27;); } WWW/name-to-db.page ğŸ“‹ &lt;script src=&quot;/scripts/getName.ts&quot;&gt;&lt;/script&gt; ğŸ“‹ #code { script(&#x27;/scripts/getName.ts&#x27;); }"},"docs/v1/global":{"titles":{"global-objects":"Global Objects","classes":"Classes","dump":"dump","local-sql":"LocalSql"},"text":"All the methods/packages/classes below will be defined globals, so you do not need to import them. you can simply use it in any SSR block/server script. A proxy to console, but only prints if the framework runs in development mode Easy way to use SQL Light, inside the project Base on sql.js ğŸ“‹ export default class LocalSql { savePath: string; //where the DataBase will be saved, the default is &#x27;/SystemSave/DataBase.db&#x27; hadChange: Boolean // this filed will auto-update with methods below. this determines if the file needs to update in the next check db: Database; //checkIntervalMinutes - check if db change and save to file constructor(savePath?: string, checkIntervalMinutes = 10); //load the db - if the folder not exists create it load(): Promise&lt;void&gt;; //templeate functions insert(queryArray: string[], ...valuesArray: any[]): number | bigint; affected(queryArray: string[], ...valuesArray: any[]): number; select(queryArray: string[], ...valuesArray: any[]): any[]; selectOne(queryArray: string[], ...valuesArray: any[]): any; } With template functions can simply do this, without being afraid of SQL injection ğŸ“‹ const myDB = new LocalSql(); await myDB.load(); const newId = myDB.insert `insert into users (name, age) values(${Post.name}, ${Post.age})`; write(`&lt;p&gt;Your userId is: ${newId}&lt;/p&gt;`);"},"docs/v1/client-jsx":{"titles":{"client-jsx-and-tsx":"Client JSX &amp; TSX","ssr-block":"SSR Block","as-static-file":"As Static File","with-compile-runtime":"With Compile Runtime"},"text":"You can use JSX &amp; TSX freely on any SSR block &amp; as separated file When you import JSX &amp; TSX it automatically transpile into regular JavaScript ğŸ“‹ &lt;script lang=jsx&gt; const div2=(&lt;div&gt;{1+1}&lt;/div&gt;); &lt;/script&gt; WWW/react/div2.tsx ğŸ“‹ const div2=(&lt;div&gt;{1+1}&lt;/div&gt;); WWW/use-div.page ğŸ“‹ &lt;script src=&quot;/scripts/div2.tsx&quot;&gt;&lt;/script&gt; ğŸ“‹ #code { script(&#x27;/scripts/div2.tsx&#x27;); }"},"docs/v1/external-packages":{"titles":{"packages":"Packages","components":"Components","models":"Models"},"text":"You can use packages to reuse components and models Add â€˜^â€™ to the start of the path, and then it will redirect to modules ğŸ“‹ &lt;List folder=&quot;^listModule&quot;/&gt; Then EAS-Framework will search for â€˜node_modules/listModule/Components/List.inteâ€™ ğŸ“‹ #[model=&#x27;^myPackage/web&#x27; title=&#x27;Home Page&#x27;] Then EAS-Framework will search for â€˜node_modules/myPackage/Models/web.modeâ€™"},"docs/v1/extends-component":{"titles":{"extends":"Extends","extends-class":"Extends Class","objects":"Objects","result":"Result","working-as-expected":"Working as expected","not-working-as-expected":"Not working as expected"},"text":"Let your children components to extend your attributes Works if the attribute not already appears in the child attributes Class attribute have a special behaver - when a class attribute already exists it will concat it to the old attribute So for this example the classes will be in this order: link nav-link active ğŸ“‹ &lt;eas-extends extends-class=&quot;link nav-link&quot;&gt; &lt;Link class=&quot;active&quot; title=&quot;Home Page&quot;/&gt; &lt;Link title=&quot;About&quot;/&gt; &lt;Link title=&quot;Concat&quot;/&gt; &lt;/eas-extends&gt; When you extends an object attribute change it in compile-runtime, it will change for all other items that extends that attribute Remember that the component compile simultaneously so donâ€™t do anything that is order base The â€˜resultâ€™ component is a special component that waiting for all the previous children to finish compile and then execute his children components ğŸ“‹ &lt;eas-extends data={count: 0}&gt; &lt;IncreaseCounter/&gt; &lt;IncreaseCounter/&gt; &lt;eas-result&gt; &lt;PrintCounter/&gt; &lt;/eas-result&gt; &lt;/eas-extends&gt; This print counter may be print 0, 1, 2 because the component compile simultaneously ğŸ“‹ &lt;eas-extends data={count: 0}&gt; &lt;IncreaseCounter/&gt; &lt;IncreaseCounter/&gt; &lt;PrintCounter/&gt; &lt;/eas-extends&gt;"},"docs/v1/getting-started":{"titles":{"getting-started":"Getting Started","vs-code-debug-support":"VS Code debug support","vs-code-extension":"VS Code extension"},"text":"Create a new project and install EAS-Framework ğŸ“‹ npm install @eas-framework/server Make your project a module project, add this to your package.json ğŸ“‹ &quot;type&quot;: &quot;module&quot; Create index.js file in your root folder ğŸ“‹ import server from &#x27;@eas-framework/server&#x27;; server(); //start the server (all the settings via Settings.js file) Create â€˜wwwâ€™ folder in your root folder that will contain all the SSR and static content of your website Create .vscode/launch.json ğŸ“‹ { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;pwa-node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program Node&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;${workspaceFolder}\\\\index.js&quot;, &quot;args&quot;: [&quot;allowSourceDebug&quot;, &quot;rebuild&quot;], // allow source debug in browser and rebuild even on production mode &quot;pauseForSourceMap&quot;: true, &quot;outFiles&quot;: [ &quot;${workspaceFolder}/node_modules/eas-framework/dist/*&quot;, &quot;${workspaceFolder}/**/*.js&quot; ] } ] } Itâ€™s recommended to install the official vscode extension for syntax highlight"},"docs/v1/client-sass":{"titles":{"client-sass":"Client Sass","inside-a-style-tag":"Inside a style tag","with-compile-runtime":"With Compile Runtime"},"text":"You can use Sass/Scss freely on any SSR block &amp; as separated file When you import Sass &amp; Scss it automatically transpile into regular css ğŸ“‹ &lt;link rel=&quot;stylesheet&quot; href=&quot;/content/main-style.sass&quot;/&gt; ğŸ“‹ &lt;style lang=&quot;sass&quot;&gt; @import &#x27;./colors.sass&#x27; body .move height: 200px &lt;/style&gt; You can also use â€œscssâ€ ğŸ“‹ #code { style(&#x27;/colors.sass&#x27;); }"},"docs/v1/client-component":{"titles":{"client-csr":"Client - CSR","how-to-use-csr":"How to use CSR?"},"text":"There is an option for CSR, it is the client tag. ğŸ“‹ &lt;div id=&quot;posts&quot;&gt;&lt;/div&gt; &lt;eas-client fn-name=&quot;andPosts&quot; params=&quot;posts, onlyName&quot; selector=&quot;#posts&quot;&gt; @for(let i in posts){ &lt;div class=&quot;post&quot;&gt; &lt;p&gt;@:i.name&lt;/p&gt; @if(!onlyName){ &lt;div class=&quot;post-body&quot;&gt; @i.body &lt;/div&gt; } &lt;/div&gt; } &lt;/eas-client&gt; &lt;script&gt; andPosts({posts: postArray, onlyName: true}); &lt;/script&gt; The CSR will also return the created children as an HTMLCollection On debug there will be js comments with CSR, you can disable them with the â€˜SafeDebugâ€™ plugin. You can change the default selector from JS bypassing another argument ğŸ“‹ andPosts({posts: postArray, onlyName: true}, &#x27;#adminPosts&#x27;);"},"docs/v1/binding-api":{"titles":{"binding-api":"Binding - API","custom-validation":"Custom validation","validate-func-method":"validateFunc Method","inside-a-define-property":"Inside a â€˜defineâ€™ property.","inside-a-url-property":"Inside a URL property","safe-debug":"Safe Debug","method":"Method","as-export":"As Export","nested":"Nested","default-function":"Default function"},"text":"Any page that ends with â€˜.api.tsâ€™ or â€˜.api.jsâ€™, will read as an API page. Every API function returns only JSON format. If a method returns text then the API call will return ğŸ“‹ {text: &quot;My Text&quot;} If the API function returns null then it wonâ€™t return anything and we need to make the return manually. ğŸ“‹ async func (Request: Request | any, Response: Response | any){ Response.json({text: &#x27;Success&#x27;}); } Start by creating a file in the path you want your API on, for example, we want our on API to be something like that: â€˜/user/:id/nameâ€™, will return the user name. For that I will create a file: user.api.js ğŸ“‹ export default { GET: { define: { &#x27;userId&#x27;: parseInt, }, &#x27;name&#x27;: { async func (Request: Request | any, Response: Response | any, [], {userId}){ return await getNameById(userId); } }, &#x27;age&#x27;: { async func (Request: Request | any, Response: Response | any, [], {userId}){ return await getAgeById(userId); } } } } For example, I can make the following HTTP request: ğŸ“‹ const userName = await fetch(&#x27;/user/43/name&#x27;); alert(&#x27;User Name: &#x27; + await userName.text()); In this example, we define the first slash as an userId with the type of an integer, if the validation/parsing fail we will get an auto-generated error. The next slash can be â€˜nameâ€™ or â€˜ageâ€™, and then the API activate. A simple example of how to validate â€˜defineâ€™ properties and custom properties. Within the â€˜defineâ€™ hash map, you can use your own methods - this is an asynchrony operation. You can also use Regex or array as an enum string. (The â€˜Booleanâ€™ function will also work) If you add â€œanyâ€ this will alow any value and wonâ€™t parse it - remaining as a string. ğŸ“‹ export default { GET: { &#x27;compare&#x27;: { define: { &#x27;userId1&#x27;: Number, &#x27;userId2&#x27;: String, async validateFunc({ userId1, userId2 }, Request: Request | any, Response: Response | any) { return (await userExists(userId1)) &amp;&amp; (await userExists(userId2)); } }, &#x27;lastLogin&#x27;: { validateURL: [ [&#x27;MM-DD-YYYY&#x27;, &#x27;MM-DD&#x27;] // enum date format check ], func(Request: Request | any, Response: Response | any, [format], { userId1, userId2 }) { return compereDate(format, userId1, userId2); } } }, // HTTP GET: /user/compere/52/89/lastLogin/MM-DD POST: { &#x27;update&#x27;: { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) } }, &#x27;image&#x27;: { validateFunc(_, Request: Request | any, Response: Response | any) { return Request.files.image; }, func(Request: Request | any, Response: Response | any, _, { userId }) { return updateImage(userId, Request.files.image); } } } } // HTTP POST: /user/update/89/image // form: {image: ImageFile} } } Can returns boolean or string. In case of an error, the API will return ğŸ“‹ async validateFunc(defineObject: {[key: string]: any}, Request: Request | any, Response: Response | any) You can add properties to â€˜defineObjectâ€™ so you can use them within â€˜funcâ€™ ğŸ“‹ async validateFunc(notParseSlashArray: string[], Request: Request | any, Response: Response | any, parsedSlashArray: any[]) You can push values to â€˜parsedSlashArrayâ€™ so you can use them within â€˜funcâ€™ If you donâ€™t want to return code info about the error you can enable the plugin â€˜SafeDebugâ€™ There are many ways to define the method. You can also no a nested definition ğŸ“‹ export const GET = { ... } export const POST = { ... } export const DELETE = { ... } ğŸ“‹ export default { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) }, }, &#x27;image&#x27;: { GET: { &#x27;size&#x27;: { func(Request: Request | any, Response: Response | any, _, { userId }) { return imageSize(fuserId); } } }, POST: { &#x27;upload&#x27;: { validateFunc(_, Request: Request | any, Response: Response | any) { return Request.files.image; }, func(Request: Request | any, Response: Response | any, _, { userId }) { return updateImage(userId, Request.files.image); } } } } } Add â€˜funcâ€™ to the root of the object ğŸ“‹ export default { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) }, }, &#x27;image&#x27;: { GET: { &#x27;size&#x27;: { func(Request: Request | any, Response: Response | any, _, { userId }) { return imageSize(fuserId); } } } }, func (Request: Request | any, Response: Response | any){ // default function Response.sendStatus(404); } }"},"docs/v1/isolate-component":{"titles":{"isolate":"Isolate"},"text":"Simply insert the code into js block {} ğŸ“‹ @code { const value = 1 } &lt;eas-isolate&gt; @{ const value = 2; } &lt;/eas-isolate&gt;"},"docs/v1/record-component":{"titles":{"record":"Record","options":"Options"},"text":"A way to store static html content ğŸ“‹ &lt;eas-record&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; Some text &lt;/eas-record&gt; This it will save in a map where the key is the request-path and the value is the html If you have multiple record on file, it will sum up ğŸ“‹ type recordMap = {[request_path: string]: string} name - the full path to the save location, default is records/record.serv link - the key in the map, default is request-path"},"docs/v1/markdown-component":{"titles":{"markdown":"Markdown","how-to-use":"How to use","options":"Options","linkify":"linkify","breaks":"breaks","typographer":"typographer","hljs-class":"hljs-class","theme":"theme","code-theme":"code-theme","header-link":"header-link","attrs":"attrs","copy-code":"copy-code"},"text":"Easy way to use markdown inside an SSR block. Syntax Highlighting build in! Simply add the markdown tag ğŸ“‹ &lt;eas-markdown&gt; # Hello World * Item in list &lt;/eas-markdown&gt; Type: boolean Default: false Uses linkify-it Type: boolean Default: true Convert â€˜\\nâ€™ in paragraphs into &lt;â€br&gt; Type: boolean Default: true Enable some language-neutral replacement * quotes beautification Type: boolean Default: true If false then it will prevent adding â€˜hljsâ€™ class (the code background) Enum: â€˜noneâ€™ | â€˜darkâ€™ | â€˜lightâ€™ | â€˜autoâ€™ Default: 'auto Enum: one of highlight.js themes Default: â€˜atom-oneâ€™ If you wanâ€™t a theme that automatically change base of the user preference (dark/light), you can do it like that: ğŸ“‹ &lt;eas-markdown code-theme=&quot;qtcreator-light|qtcreator-dark&quot;&gt; Type: boolean Default: true Make header as links markdown-it-anchor Type: boolean Default: true Easy use of abbr element markdown-it-abbr Type: string Default: â€˜ğŸ“‹â€™ HTML to show as the copy-code button Full documentation at the repository of markdown-it"},"docs/v1/mpc":{"titles":{"what-is-eas-framework":"What is EAS-Framework?","examples":"Examples","folders":"Folders","components":"Components","nested":"Nested","models":"Models","special-component-attributes":"Special component attributes","example":"Example"},"text":"EAS stands for embedded active server. This is an SSR (server-side rendering) for Node.JS. Its basic concept is page-model-component, a bit similar to asp. model example: www/Site.mode ğŸ“‹ &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;:title/&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;:body/&gt; &lt;/body&gt; &lt;/html&gt; component example: www/ColorButton.inte (component name must be capitalize) ğŸ“‹ #default(&#x27;color&#x27;, &#x27;blue&#x27;) &lt;button style=&quot;background-color:~color&quot;&gt; &lt;:reader/&gt; &lt;/button&gt; page example: www/index.page ğŸ“‹ #[model=&#x27;./Site&#x27; title=&#x27;This is Home Page&#x27;] &lt;content:body&gt; &lt;p&gt;This is a big placeholder&lt;/p&gt; &lt;ColorButton folder=&quot;./&quot;&gt;Blue Button&lt;/ColorButton&gt; &lt;ColorButton folder=&quot;./&quot; color=&quot;red&quot;&gt;Red Button&lt;/ColorButton&gt; @code { if(!Cookies.counter) Cookies.counter = 0 Cookies.counter++ } &lt;p&gt;Counter: @(Cookies.counter)&lt;/p&gt; &lt;/content:body&gt; All those folders must be on the root folder If exists contains components that doesnâ€™t need a â€˜folderâ€™ attribute ğŸ“‹ &lt;ColorButton&gt;Blue Button&lt;/ColorButton&gt; You can do nested components like that: ğŸ“‹ &lt;Colors:Button&gt;Blue Button&lt;/Colors:Button&gt; Colors is the folder and Button is the component file If exists contains models that doesnâ€™t need a relative or absolute path ğŸ“‹ #[model=Site] importSource - The file that imported this component importSourceDirectory - The directory of the file that imported this component If WWW/docs/search.page import Components/TitleIt.inte Then importSource will be WWW/docs/search.page - relative to the website directory"},"docs/v1/server-files":{"titles":{"how-to-add-a-server-script":"How to add a server script","import-on-start":"Import on start"},"text":"Files that end with â€˜.serv.jsâ€™ or â€˜.serv.tsâ€™ (When TypeScript enabled) will not be visible as normal text files and can only be imported by the server. If you need file to be imported as the server start you can add the path to the Settings file Setting file will search the file in the WWW folder ğŸ“‹ general: { importOnLoad: [&quot;OnStart.serv.ts&quot;] } The server will try to call function name â€˜StartServerâ€™ ğŸ“‹ function StartServer(app: TinyApp, { server: http.server, close: () =&gt; void }, Settings: ExportSettings)"},"docs/v1/search-component":{"titles":{"search":"Search","options":"Options","using-the-search":"Using the search"},"text":"Similar to record but for search purposes This will extract titles from the texts ğŸ“‹ &lt;eas-search&gt; &lt;h1 id=&quot;home-page&quot;&gt;Home Page&lt;/h1&gt; Some text &lt;/eas-search&gt; ğŸ“‹ type searchMap = {[request-path]: { titles: {[key: objectId]: string} text: string }} name - the full path to the save location, default is records/search.serv link - the key in the map, default is request-path match - query selector for ids, default is â€˜h1[id]â€¦h6[id]â€™ You can search in a â€˜search-recordâ€™ with the build in â€˜SearchRecordâ€™ class ğŸ“‹ import {SearchRecord} from &#x27;@eas-framework/server&#x27; const textSearch = new SearchRecord(&#x27;records/search.serv&#x27;) await textSearch.load() export function queryText(query){ return textSearch.search(query) } You can use then with SSR block ğŸ“‹ @code { import {queryText} from &#x27;./searchFile.serv.js&#x27; } @for(const {text, url} of queryText(Query.q ?? &#x27;new&#x27;)){ &lt;a href=&quot;@url&quot;&gt;@:text&lt;/a&gt; }"},"docs/v1/settings-file":{"titles":{"settings-file":"Settings File","recommended-settings":"Recommended Settings","all-settings":"All Settings"},"text":"The settings file can be a TypeScript file OR JavaScript file. In this example, we use a JavaScript file In our root folder, we create Settings.js ğŸ“‹ export default { development: true, // development mode, if off, then is optimize for production general: { pageInRam: true, }, implDev: { serveLimits: { cacheDays: 0 } } } ğŸ“‹ export default { development: true, // development mode, if off, then is optimize for production general: { pageInRam: true, importOnLoad: [&quot;OnStart.serv.ts&quot;] // Search for &#x27;StartServer&#x27; function (app: TinyApp, {server: http.server, listen: (port) =&gt; {}, close: () =&gt; {}}, settings: ExportSettings) }, compile: { compileSyntax: [&quot;TypeScript&quot;], ignoreError: [], //&quot;close-tag&quot; | &quot;component-not-found&quot; | &quot;ts-warning&quot; | &quot;js-warning&quot; | &quot;page-not-found&quot; | &quot;sass-import-not-found&quot; | &quot;css-warning&quot; | &quot;compilation-error&quot; | &quot;jsx-warning&quot; | &quot;tsx-warning&quot; plugins: [], // &quot;MinAll&quot; | &quot;MinHTML&quot; | &quot;MinCss&quot; | &quot;MinSass&quot; | &quot;MinJS&quot; | &quot;MinTS&quot; | &quot;MinJSX&quot; | &quot;MinTSX&quot;... define: { // global define - will bee explained later name: &#x27;cool&#x27;, version: 20 }, pathAliases: { // esm path aliases (not for dynamic imports) &quot;@imr&quot;: &quot;/server/import/&quot; // for example: import {func} from &#x27;@imp/data.serv.js&#x27; -&gt; import {func} from &#x27;/server/import/data.serv.js&#x27; // (&#x27;/&#x27; is relative to the WWW folder) }, global: { // const variables that available globaly versionDate: Date.now() } }, routing: { rules: { &quot;/Examples/User/&quot;: (url, req, res) =&gt; &#x27;/Files/User/Examples/&#x27; + url.split(&#x27;/&#x27;).pop() }, urlStop: [ // make sure any path after x remains same as x, for example /admin/editUsers/34234/cool =&gt; /admin/editUsers &quot;/User/Files&quot; ], errorPages: false || { notFound: { code: 404, path: &quot;errors/e404&quot; }, serverError: { code: 500, path: &quot;errors/e500&quot; } }, sitemap: true || { rules: true, urlStop: false, errorPages: false, validPath: true, file: &#x27;sitemap.xml&#x27;, updateAfterHours: 0 // update sitemap on new request after x hours }, ignoreTypes: [&quot;json&quot;], // ignore file extension (auto ignore common server files) ignorePaths: [&quot;/Private&quot;], validPath: [(url, req, res) =&gt; url.substring(3, 5) != &#x27;hi&#x27;] // check url path, if one of the methods return false, then the server returns a 404 }, serveLimits: { cacheDays: 3, fileLimitMB: 10, requestLimitMB: 4, cookiesExpiresDays: 1, sessionTotalRamMB: 150, sessionTimeMinutes: 40, sessionCheckPeriodMinutes: 30, }, serve: { port: 8080, http2: false, greenLock: { // for production agreeToTerms: false, email: &quot;example@@example.com&quot;, sites: [{ &quot;subject&quot;: &quot;example.com&quot;, &quot;altnames&quot;: [&quot;example.com&quot;, &quot;www.example.com&quot;] }] } }, //custom settings - same as above but only active if development is on/off implDev: { //custom settings for development }, implProd: { //custom settings for production } }"},"docs/v1/ssr":{"titles":{"how-to-use-the-ssr":"How to use the SSR?","global-object":"Global Object","global-methods":"Global Methods","echo":"Echo","stop":"Stop","sending-the-controllers-of-the-page":"Sending the controllers of the page","global-variable-in-every-file-not-just-ssr-blocks":"Global variable in every file (not just SSR blocks)","model":"Model","component":"Component","default-values":"Default values","page-placeholders-data":"Page Placeholders Data","small-placeholder":"Small Placeholder","define-data":"Define data","add-page-inside-a-page":"Add Page Inside A Page","separate-code-file":"Separate Code File","enforce-js":"Enforce JS"},"text":"Basically, every SSR block (page, model, component) with a razor-like rendering ğŸ“‹ #*Simple Comment - this is who to write SSR block *# @code { let i = 0; i++; } #*This is how to print escaped text*# Count Razor: @:(i) #*This is how to write literal HTML*# @(&quot;&lt;p&gt;Text Razor&lt;/p&gt;&quot;) in each SSR block, these variables are global Response - TinyHttp response object Request - TinyHttp request object Post - null if the method isnâ€™t a post Query - map of the query string Session - Only works if the session enable (in the settings session time bigger than 0) Files - formidable files Cookies - map of the cookie data (setting and removing will affect the cookies) PageVar - public variable to all the SSR blocks in the request GlobalVar - public variable to all the SSR blocks in each SSR block, these methods are global include(path, object: extends page object) - for include another SSR block - page or component transfer(path, preserveForm: boolean - send the form to another page, object: extends page object) - transfer to another page without redirect echo - template function for writing escaped HTML write - writing HTML writeSafe - writing escaped HTML setResponse - replaceing every HTML that commit to print Echo is a template function for writing safe HTML without XSS security risk ğŸ“‹ echo `&lt;p&gt;User name is: ${Post.name}&lt;/p&gt;` This will print: ğŸ“‹ &lt;p&gt;User name is: &amp;#73;&amp;#100;&amp;#111;&lt;/p&gt; If you want to immediately stop the page process (equals to return/break), you can call the stop function index.page.js ğŸ“‹ if(something){ Response.redirect(&#x27;/&#x27;) stop() } There is a â€˜pageâ€™ variable that contains all the variables and methods above. This is useful when you want to send all the page controllers to a function at once. __dirname - the current folder (although it is a model, eas-framework create that for easy use) __filename - the current filename (although it is a model, eas-framework create that for easy use) __DEBUG__ - boolean, true if you in debug mode Model is a template with placeholders to use by a page. Use can use nested models as well. For example: www/site-model/site.mode ğŸ“‹ &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;:title/&gt;&lt;/title&gt; &lt;:head/&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My First WebSite&lt;/p&gt; &lt;div&gt; &lt;Link folder=&quot;./&quot; to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link folder=&quot;./&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link folder=&quot;./&quot; to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt; &lt;/div&gt; &lt;:body/&gt; &lt;/body&gt; &lt;/html&gt; www/site-model/Link.inte ğŸ“‹ &lt;style&gt; .link-navbar { color:rgb(44, 117, 185); font-weight: bold; } &lt;/style&gt; &lt;a href=&quot;~to&quot; class=&quot;link-navbar&quot;&gt; &lt;:reader/&gt; &lt;/a&gt; All content of script/style tags will be written only once in separate script and style files. You can prevent this if you need SSR inside the script/style tag with the â€˜serverâ€™ attribute. You can add default values in this form ğŸ“‹ #default(&#x27;key&#x27;, &#x27;value&#x27;) #default([&#x27;key1&#x27;, &#x27;key2&#x27;], true) For Example ğŸ“‹ #default(&#x27;to&#x27;, &#x27;/Home&#x27;) &lt;a href=&quot;~to&quot; class=&quot;link-navbar&quot;&gt; &lt;:reader/&gt; &lt;/a&gt; www/index.page ğŸ“‹ &lt;content:model&gt;/site-model/site&lt;/content:model&gt; &lt;content:body&gt; &lt;h1&gt;Hello Home Page&lt;/h1&gt; &lt;/content:body&gt; www/about.page ğŸ“‹ &lt;content:model&gt;/site-model/site&lt;/content:model&gt; &lt;content:body&gt; @code { export function printEmail(email){ write(`&lt;p&gt;You can concat me at ${email}&lt;/p&gt;`) } } &lt;/content:body&gt; There is a better way to write data of small placeholders. You can use â€˜Page Baseâ€™ ğŸ“‹ #[title=Home model=&quot;/site-model/site&quot;] This can alow be good if you want to save a placeholder between models. If you havenâ€™t used the placeholder but you want it to stay in the current model /user-model/user ğŸ“‹ #[title=inherit header=inherit model=&quot;/site-model/site&quot;] If you have pieces of code that repeat many times inside your code. For example path to a component or some attribute, you can define a small placeholder inside your page/model ğŸ“‹ #define(&#x27;site&#x27;, &#x27;/site-model/component/&#x27;) &lt;NavButton folder=&quot;:site:&quot;&gt;Very cool!&lt;/NavButton&gt; The way â€˜defineâ€™ works is: checking first if a value exists on-page if not checking the model and so onâ€¦ www/contact.page ğŸ“‹ &lt;eas-page form=&quot;./about&quot;/&gt; &lt;p&gt;You can concat me at example@email.com&lt;/p&gt; All the examples below will work the same with components You can also add page programmatically - this is done in runtime - slower ğŸ“‹ @include(&quot;./about.page&quot;) &lt;p&gt;You can concat me at example@email.com&lt;/p&gt; If your page export things, you can get them like that ğŸ“‹ @code { const {printEmail} = await include(&#x27;./about.page&#x27;) printEmail(&quot;example@email.com&quot;) } You can separate the server-side code to a different file that will connect to a page/model/component by using the â€˜codefileâ€™ placeholder My Page: WWW/About.page ğŸ“‹ #[codefile=inherit] The inherit will replace by â€˜WWW/About.page.jsâ€™ or â€˜WWW/About.page.tsâ€™ (if TypeScript enabled) You can alow specify exactly the file ğŸ“‹ #[codeFile=&quot;./About.page.ts&quot;] If TypeScript is enabled you can enforce JavaScript by adding â€˜lang=jsâ€™ ğŸ“‹ #[codefile=inherit lang=js]"},"docs/v1/ssr-compile":{"titles":{"compile-run-time":"Compile RunTime","methods":"Methods","define":"define","script":"script","style":"style","dependence":"dependence","attrs-html":"attrsHTML","only-attrs":"Only attrs","value-data":"Value Data","attrs-object-html":"attrsObjectHTML","variables":"Variables","store":"store","page-filename":"page__filename","page-dirname":"page__dirname","localpath-the-request-path":"__localpath - the request-path","filename":"__filename","dirname":"__dirname","only-on-components":"Only on components","attrs":"attrs","object":"Object"},"text":"Instead of running everything every request, you can run script on compile time! This runtime donâ€™t works with page-base, only with tag-value ğŸ“‹ #code { define(&#x27;create&#x27;, new Date().toLocaleString()); } &lt;p&gt;Page Created: :create:&lt;/p&gt; Use the define feature ğŸ“‹ function define(key: string, value: string) Add script file to the head tag (only if not already exists) ğŸ“‹ function script(path: string, attributes: {[key: string]: string}) Add style file to the head tag (only if not already exists) ğŸ“‹ function script(path: string, attributes: {[key: string]: string}) Add file as dependence, meaning if this file changes then the page will rebuild (hot-reload), on debug mode. There is a support for relative path, and absolute path (from WWW folder) If the file not-exits or already added to dependencies then the function return false ğŸ“‹ function dependence(path: string): Promise&lt;boolean&gt; Enable you to randers js map as HTML attributes ğŸ“‹ function attrsHTML(...onlyAttrs?: string[]) // default form &#x27;attrs&#x27; object function attrsHTML(attrObject: {[key: string]: any}, ...onlyAttrs?: string[]) Randers only specific attribute attribute Example: ğŸ“‹ &lt;!--index.page--&gt; &lt;Some folder class=&quot;form-control&quot; style=&quot;width:200px&quot;/&gt; &lt;!--Some.inte--&gt; &lt;input #(attrsHTML())/&gt; True = Randers only the key ğŸ“‹ const data = {checked: true} &lt;input checked /&gt; False, null, undefined - skip this attribute Same as attrsHTML but randers as object attribute attrsObjectHTML is for using in another component ğŸ“‹ &lt;!--index.page--&gt; &lt;Some folder class=&quot;form-control&quot; counter=(10) keywords=[&#x27;This&#x27;, &#x27;is&#x27;, &#x27;cool&#x27;, &#x27;!!!&#x27;] style=&quot;width:200px&quot;/&gt; &lt;!--Some.inte--&gt; &lt;DataInput folder #(attrsObjectHTML())/&gt; &lt;!--DataInput.inte--&gt; &lt;div #(attrsHTML(&#x27;class&#x27;, &#x27;style&#x27;))&gt; #code { write(`&lt;p&gt;Counter is ${attributes.counter}, keywords: ${attributes.keywords.join(&#x27;, &#x27;)}&lt;/p&gt;`) } &lt;/div&gt; The â€˜storeâ€™ variable will be available for all the compile block in the page. Regular variable will be only available in same ssr file, everything inside â€˜storeâ€™ variable will be available through all page ğŸ“‹ #code { store.counter++; } Full path to page Full path to page directory Same as â€˜page__filenameâ€™ but relative to the website folder without the file extension Full path to this file Full path to this directory An â€˜attrsâ€™ map for then attributes in the component. The â€˜readerâ€™ key if for the html inside of the tag ğŸ“‹ var attrs: {[key: string]: string | true | object} The attribute data will be an object/js-parse only if it is in this syntax: ğŸ“‹ &lt;Counter data=({start: 2, name: &#x27;Json&#x27;}) string=&quot;whatever&quot;/&gt; ğŸ“‹ &lt;List array=([&#x27;array&#x27;, &#x27;of&#x27; &#x27;items&#x27;])/&gt; ğŸ“‹ &lt;AboutNum num=(1) openDialog=(false)/&gt;"},"docs/v1/troubleshooting":{"titles":{"troubleshooting":"Troubleshooting","debugging":"Debugging"},"text":"Sometimes some files loaded before the breakpoint register on vs code. If your breakpoint not stop, use the debugger keyword to force a breakpoint stop Also works if you debug a client JS/TS file"}}