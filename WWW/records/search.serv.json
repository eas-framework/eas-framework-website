{"docs/v1/examples":{"titles":{"examples":"Examples","git-repositories":"Git Repositories"},"text":"The examples below EAS-Framework best-practices Simple Calculator Simple Gallery WS Chat This Website"},"docs/v1/client-component":{"titles":{"client-csr":"Client - CSR","how-to-use-csr":"How to use CSR?"},"text":"There is an option for CSR, it is the client tag. ğŸ“‹ &lt;div id=&quot;posts&quot;&gt;&lt;/div&gt; &lt;client name=&quot;andPosts&quot; params=&quot;posts, onlyName&quot; selector=&quot;#posts&quot;&gt; @for(let i in posts){ &lt;div class=&quot;post&quot;&gt; &lt;p&gt;@:i.name&lt;/p&gt; @if(!onlyName){ &lt;div class=&quot;post-body&quot;&gt; @i.body &lt;/div&gt; } &lt;/div&gt; } &lt;/client&gt; &lt;script&gt; andPosts({posts: postArray, onlyName: true}); &lt;/script&gt; The CSR will also return the created children as an HTMLCollection On debug there will be js comments with CSR, you can disable them with the â€˜SafeDebugâ€™ plugin. You can change the default selector from JS bypassing another argument ğŸ“‹ andPosts({posts: postArray, onlyName: true}, &#x27;#adminPosts&#x27;);"},"docs/v1/cli-commands":{"titles":{"cli-commends":"CLI Commends"},"text":""},"docs/v1/external-packages":{"titles":{"packages":"Packages","components":"Components","models":"Models"},"text":"You can use packages to reuse components and models Add â€˜^â€™ to the start of the path, and then it will redirect to modules ğŸ“‹ &lt;List folder=&quot;^listModule&quot;/&gt; Then EAS-Framework will search for â€˜node_modules/listModule/Components/List.inteâ€™ ğŸ“‹ @[model=&#x27;^myPackage/web&#x27; title=&#x27;Home Page&#x27;] Then EAS-Framework will search for â€˜node_modules/myPackage/Models/web.modeâ€™"},"docs/v1/client-sass":{"titles":{"client-sass":"Client Sass","inside-a-style-tag":"Inside a style tag","with-compile-runtime":"With Compile Runtime"},"text":"You can use Sass/Scss freely on any SSR block &amp; as separated file When you import Sass &amp; Scss it automatically transpile into regular css ğŸ“‹ &lt;link rel=&quot;stylesheet&quot; href=&quot;/content/main-style.sass&quot;/&gt; ğŸ“‹ &lt;style lang=&quot;sass&quot;&gt; @import &#x27;./colors.sass&#x27; body .move height: 200px &lt;/style&gt; You can also use â€œscssâ€ ğŸ“‹ @compile{ style(&#x27;/colors.sass&#x27;); }"},"docs/v1/client-svelte":{"titles":{"svelte-component":"Svelte Component","ssr":"SSR","sass-type-script":"Sass, TypeScript"},"text":"The JS and CSS will be auto-import to the page All props will copied to the svelte app ğŸ“‹ &lt;svelte from=&quot;./path/to/svelte-file&quot; props={counter: 0, name: &#x27;Cool-Website&#x27;}/&gt; The framework will auto-generate div with id the svelte render as a target. You can prevent that by passing your own selector ğŸ“‹ &lt;svelte from=&quot;./path/to/svelte-file&quot; selector=&quot;#todo&quot;/&gt; You can also only change the id that the framework use for the div. ğŸ“‹ &lt;svelte from=&quot;./path/to/svelte-file&quot; id=&quot;#todo&quot;/&gt; Simply add â€˜SSRâ€™ attribute, the framework will do the rest. You canâ€™t use â€˜selectorâ€™ cause there need to be SSR writing to the page, but you can change the id. ğŸ“‹ &lt;svelte from=&quot;./path/to/svelte-file&quot; ssr/&gt; If you wondering, yes all of that is supported inside of the svelte file with the framework. On debug mode source map will be inserted automatically ğŸ“‹ &lt;style lang=sass&gt; If you use TypeScript with svelte import all types via â€˜import typeâ€™, so esbuild will know what to remove. This is necessary only on svelte because how svelte works ğŸ“‹ &lt;script lang=ts&gt; @@import type {coolType} from &#x27;./location.ts&#x27; const beType: coolType = {attr1: 1, attr2: 2}; &lt;/script&gt;"},"docs/v1/binding-api":{"titles":{"binding-api":"Binding - API","custom-validation":"Custom validation","validate-func-method":"validateFunc Method","inside-a-define-property":"Inside a â€˜defineâ€™ property.","inside-a-url-property":"Inside a URL property","safe-debug":"Safe Debug","method":"Method","as-export":"As Export","nested":"Nested","default-function":"Default function"},"text":"Any page that ends with â€˜.api.tsâ€™ or â€˜.api.jsâ€™, will read as an API page. Every API function returns only JSON format. If a method returns text then the API call will return ğŸ“‹ {text: &quot;My Text&quot;} If the API function returns null then it wonâ€™t return anything and we need to make the return manually. ğŸ“‹ async func (Request: Request | any, Response: Response | any){ Response.json({text: &#x27;Success&#x27;}); } Start by creating a file in the path you want your API on, for example, we want our on API to be something like that: â€˜/user/:id/nameâ€™, will return the user name. For that I will create a file: user.api.js ğŸ“‹ export default { GET: { define: { &#x27;userId&#x27;: parseInt, }, &#x27;name&#x27;: { async func (Request: Request | any, Response: Response | any, [], {userId}){ return await getNameById(userId); } }, &#x27;age&#x27;: { async func (Request: Request | any, Response: Response | any, [], {userId}){ return await getAgeById(userId); } } } } For example, I can make the following HTTP request: ğŸ“‹ const userName = await fetch(&#x27;/user/43/name&#x27;); alert(&#x27;User Name: &#x27; + await userName.text()); In this example, we define the first slash as an userId with the type of an integer, if the validation/parsing fail we will get an auto-generated error. The next slash can be â€˜nameâ€™ or â€˜ageâ€™, and then the API activate. A simple example of how to validate â€˜defineâ€™ properties and custom properties. Within the â€˜defineâ€™ hash map, you can use your own methods - this is an asynchrony operation. You can also use Regex or array as an enum string. (The â€˜Booleanâ€™ function will also work) If you add â€œanyâ€ this will alow any value and wonâ€™t parse it - remaining as a string. ğŸ“‹ export default { GET: { &#x27;compare&#x27;: { define: { &#x27;userId1&#x27;: Number, &#x27;userId2&#x27;: String, async validateFunc({ userId1, userId2 }, Request: Request | any, Response: Response | any) { return (await userExists(userId1)) &amp;&amp; (await userExists(userId2)); } }, &#x27;lastLogin&#x27;: { validateURL: [ [&#x27;MM-DD-YYYY&#x27;, &#x27;MM-DD&#x27;] // enum date format check ], func(Request: Request | any, Response: Response | any, [format], { userId1, userId2 }) { return compereDate(format, userId1, userId2); } } }, // HTTP GET: /user/compere/52/89/lastLogin/MM-DD POST: { &#x27;update&#x27;: { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) } }, &#x27;image&#x27;: { validateFunc(_, Request: Request | any, Response: Response | any) { return Request.files.image; }, func(Request: Request | any, Response: Response | any, _, { userId }) { return updateImage(userId, Request.files.image); } } } } // HTTP POST: /user/update/89/image // form: {image: ImageFile} } } Can returns boolean or string. In case of an error, the API will return ğŸ“‹ async validateFunc(defineObject: {[key: string]: any}, Request: Request | any, Response: Response | any) You can add properties to â€˜defineObjectâ€™ so you can use them within â€˜funcâ€™ ğŸ“‹ async validateFunc(notParseSlashArray: string[], Request: Request | any, Response: Response | any, parsedSlashArray: any[]) You can push values to â€˜parsedSlashArrayâ€™ so you can use them within â€˜funcâ€™ If you donâ€™t want to return code info about the error you can enable the plugin â€˜SafeDebugâ€™ There are many ways to define the method. You can also no a nested definition ğŸ“‹ export const GET = { ... } export const POST = { ... } export const DELETE = { ... } ğŸ“‹ export default { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) }, }, &#x27;image&#x27;: { GET: { &#x27;size&#x27;: { func(Request: Request | any, Response: Response | any, _, { userId }) { return imageSize(fuserId); } } }, POST: { &#x27;upload&#x27;: { validateFunc(_, Request: Request | any, Response: Response | any) { return Request.files.image; }, func(Request: Request | any, Response: Response | any, _, { userId }) { return updateImage(userId, Request.files.image); } } } } } Add â€˜funcâ€™ to the root of the object ğŸ“‹ export default { define: { &#x27;userId&#x27;: Number, async validateFunc({ userId }, Request: Request | any, Response: Response | any) { return await userExists(userId) }, }, &#x27;image&#x27;: { GET: { &#x27;size&#x27;: { func(Request: Request | any, Response: Response | any, _, { userId }) { return imageSize(fuserId); } } } }, func (Request: Request | any, Response: Response | any){ // default function Response.sendStatus(404); } }"},"docs/v1/binding-form":{"titles":{"binding-form":"Binding - Form","simple-form":"Simple form","validation":"Validation","validation-types":"Validation Types","simple-types":"Simple Types","complex-validation":"Complex Validation","validation-options":"Validation Options","prevent-html-on-error-message":"Prevent HTML on error message"},"text":"There are many ways to use a form, in this guild we will focus on best practices ğŸ“‹ @{ if(Post){ if(testLogin(Post.email, Post.password)) return Response.redirect(&#x27;/&#x27;); write(&#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;); } } &lt;form action=&quot;post&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; EAS Framework, provide a better way of doing so ğŸ“‹ @{ function checkLogin(email, password){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; Change input order You can change the input order with the â€˜orderâ€™ attribute ğŸ“‹ @{ function checkLogin(password,email){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; order=&quot;password,email&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; We can also add validation as needed ğŸ“‹ @{ function checkLogin(email, password){ if(testLogin(email, password)) return null, Response.redirect(&#x27;/&#x27;); return &#x27;&lt;p&gt;Wrong email or password&lt;/p&gt;&#x27;; } } &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; validator=&quot;email:email,password:6-30&quot;&gt; &lt;input type=&quot;email&quot; name=&quot;email&quot; placeholder=&quot;Enter your email address&quot;/&gt; &lt;input type=&quot;password&quot; name=&quot;password&quot; placeholder=&quot;Enter your password&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; The order of the fields in â€˜validatorâ€™ is the order of the arguments the â€˜sendToâ€™ function get A simple way to validate and parse a form data â€˜Regexâ€™ and â€˜Functionâ€™ validation will not parse the form data Number Intger Boolean String Email Name number integer boolean string email Shorthand num int bool text String Length Range Number Range String Enum Number Enum Regex Function Example 6-10 -5â€¦15 string =&gt; cat | dog number =&gt; 1 | 8 /^[a-z]+[0-9]$/ myFunction Comment Between 6 to 10 string length Between -5 to 15 number range Multiple choice for string Multiple choice for number Can be any Regex instance If none of the previous methods is possible, it will call the function. The function can be asynchrony You can use any shorthand in enum Default error message By default, the framework will enable auto-generate error messages in debug mode. You can disable it by setting â€˜message=falseâ€™ OR if you want to them in production set â€˜message=trueâ€™ If you want to disable it globally you can enable the â€œSafeDebugâ€ plugin ğŸ“‹ &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; validator=&quot;email:email,password:6-30&quot; message=&quot;false&quot;&gt; You can also override the auto-generate error message and set the message to be a string ğŸ“‹ &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; validator=&quot;email:email,password:6-30&quot; message=&quot;Make sure the email valid and password between 6 to 30 characters&quot;&gt; Custom error event â€˜notValidâ€™ attribute contains the name of the function that will be called in case of an error. The function will get the ğŸ“‹ function(message: string, validationType: string (name_of_validation_type) | RegExp | method, validationArguments: []number | []string, value: string | number | boolean): Promise&lt;any&gt; | any Example ğŸ“‹ @{ function thatError(message, type){ return `There is an error in that type: ${type}`; } } &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; validator=&quot;email:email,password:6-30&quot; notValid=&quot;thatError&quot;&gt; To escape HTML on error message add the â€˜safeâ€™ tag. ğŸ“‹ &lt;form action=&quot;post&quot; sendTo=&quot;checkLogin&quot; validator=&quot;email:email,password:6-30&quot; message=&quot;This &lt;/p&gt; will not cause an error&quot; safe&gt;"},"docs/v1/getting-started":{"titles":{"getting-started":"Getting Started","vs-code-debug-support":"VS Code debug support","vs-code-extension":"VS Code extension"},"text":"Create a new project and install EAS-Framework ğŸ“‹ npm install @eas-framework/server Make your project a module project, add this to your package.json ğŸ“‹ &quot;type&quot;: &quot;module&quot; Create index.js file in your root folder ğŸ“‹ import server from &#x27;@eas-framework/server&#x27;; server(); //start the server (all the settings via Settings.js file) Create â€˜wwwâ€™ folder in your root folder that will contain all the SSR and static content of your website Create .vscode/launch.json ğŸ“‹ { &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;pwa-node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Program Node&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;${workspaceFolder}\\\\index.js&quot;, &quot;args&quot;: [&quot;allowSourceDebug&quot;, &quot;rebuild&quot;], // allow source debug in browser and rebuild even on production mode &quot;pauseForSourceMap&quot;: true, &quot;outFiles&quot;: [ &quot;${workspaceFolder}/node_modules/eas-framework/dist/*&quot;, &quot;${workspaceFolder}/**/*.js&quot; ] } ] } Itâ€™s recommended to install the official vscode extension for syntax highlight"},"docs/v1/troubleshooting":{"titles":{"troubleshooting":"Troubleshooting","debugging":"Debugging"},"text":"Sometimes some files loaded before the breakpoint register on vs code. If your breakpoint not stop, use the debugger keyword to force a breakpoint stop Also works if you debug a client JS/TS file"},"docs/v1/client-jsx":{"titles":{"client-jsx-and-tsx":"Client JSX &amp; TSX","ssr-block":"SSR Block","as-static-file":"As Static File","with-compile-runtime":"With Compile Runtime"},"text":"You can use JSX &amp; TSX freely on any SSR block &amp; as separated file When you import JSX &amp; TSX it automatically transpile into regular JavaScript ğŸ“‹ &lt;script lang=jsx&gt; const div2=(&lt;div&gt;{1+1}&lt;/div&gt;); &lt;/script&gt; WWW/react/div2.tsx ğŸ“‹ const div2=(&lt;div&gt;{1+1}&lt;/div&gt;); WWW/use-div.page ğŸ“‹ &lt;script src=&quot;/scripts/div2.tsx&quot;&gt;&lt;/script&gt; ğŸ“‹ @compile{ script(&#x27;/scripts/div2.tsx&#x27;); }"},"docs/v1/isolate-component":{"titles":{"isolate":"Isolate"},"text":"Simply insert the code into js block {} ğŸ“‹ @{ const value = 1 } &lt;isolate&gt; @{ const value = 2; } &lt;/isolate&gt;"},"docs/v1/global":{"titles":{"global-objects":"Global Objects","classes":"Classes","dump":"dump","local-sql":"LocalSql"},"text":"All the methods/packages/classes below will be defined globals, so you do not need to import them. you can simply use it in any SSR block/server script. A proxy to console, but only prints if the framework runs in development mode Easy way to use SQL Light, inside the project Base on sql.js ğŸ“‹ export default class LocalSql { savePath: string; //where the DataBase will be saved, the default is &#x27;/SystemSave/DataBase.db&#x27; hadChange: Boolean // this filed will auto-update with methods below. this determines if the file needs to update in the next check db: Database; //checkIntervalMinutes - check if db change and save to file constructor(savePath?: string, checkIntervalMinutes = 10); //load the db - if the folder not exists create it load(): Promise&lt;void&gt;; //templeate functions insert(queryArray: string[], ...valuesArray: any[]): number | bigint; affected(queryArray: string[], ...valuesArray: any[]): number; select(queryArray: string[], ...valuesArray: any[]): any[]; selectOne(queryArray: string[], ...valuesArray: any[]): any; } With template functions can simply do this, without being afraid of SQL injection ğŸ“‹ const myDB = new LocalSql(); await myDB.load(); const newId = myDB.insert `insert into users (name, age) values(${Post.name}, ${Post.age})`; write(`&lt;p&gt;Your userId is: ${newId}&lt;/p&gt;`);"},"docs/v1/settings-file":{"titles":{"settings-file":"Settings File","recommended-settings":"Recommended Settings","all-settings":"All Settings"},"text":"The settings file can be a TypeScript file OR JavaScript file. In this example, we use a JavaScript file In our root folder, we create Settings.js ğŸ“‹ export default { development: true, // development mode, if off, then is optimize for production general: { pageInRam: true, }, implDev: { serveLimits: { cacheDays: 0 } } } ğŸ“‹ export default { development: true, // development mode, if off, then is optimize for production general: { pageInRam: true, importOnLoad: [&quot;OnStart.serv.ts&quot;] // Search for &#x27;StartServer&#x27; function (app: TinyApp, {server: http.server, listen: (port) =&gt; {}, close: () =&gt; {}}, settings: ExportSettings) }, compile: { compileSyntax: [&quot;TypeScript&quot;], ignoreError: [], //&quot;close-tag&quot; | &quot;component-not-found&quot; | &quot;ts-warning&quot; | &quot;js-warning&quot; | &quot;page-not-found&quot; | &quot;sass-import-not-found&quot; | &quot;css-warning&quot; | &quot;compilation-error&quot; | &quot;jsx-warning&quot; | &quot;tsx-warning&quot; plugins: [], // &quot;MinAll&quot; | &quot;MinHTML&quot; | &quot;MinCss&quot; | &quot;MinSass&quot; | &quot;MinJS&quot; | &quot;MinTS&quot; | &quot;MinJSX&quot; | &quot;MinTSX&quot;... define: { // global define - will bee explained later name: &#x27;cool&#x27;, version: 20 } }, routing: { rules: { &quot;/Examples/User/&quot;: (url, req, res) =&gt; &#x27;/Files/User/Examples/&#x27; + url.split(&#x27;/&#x27;).pop() }, urlStop: [ // make sure any path after x remains same as x, for example /admin/editUsers/34234/cool =&gt; /admin/editUsers &quot;/User/Files&quot; ], errorPages: false || { notFound: { code: 404, path: &quot;errors/e404&quot; }, serverError: { code: 500, path: &quot;errors/e500&quot; } }, sitemap: true || { rules: true, urlStop: false, errorPages: false, validPath: true, file: &#x27;LoadSettings.serv.ts&#x27; // search for &#x27;Sitemap&#x27; function (pagesPath: string[], {pages: [path, folder -&gt; &#x27;WWW&#x27; | &#x27;Logs&#x27;][], files: string[], scripts: string[]}, settings: ExportSettings): boolean | string - return path to save the file }, ignoreTypes: [&quot;json&quot;], // ignore file extension (auto ignore common server files) ignorePaths: [&quot;/Private&quot;], validPath: [(url, req, res) =&gt; url.substring(3, 5) != &#x27;hi&#x27;] // check url path, if one of the methods return false, then the server returns a 404 }, serveLimits: { cacheDays: 3, fileLimitMB: 10, requestLimitMB: 4, cookiesExpiresDays: 1, sessionTotalRamMB: 150, sessionTimeMinutes: 40, sessionCheckPeriodMinutes: 30, }, serve: { port: 8080, http2: false, greenLock: { // for production agreeToTerms: false, email: &quot;example@@example.com&quot;, sites: [{ &quot;subject&quot;: &quot;example.com&quot;, &quot;altnames&quot;: [&quot;example.com&quot;, &quot;www.example.com&quot;] }] } }, //custom settings - same as above but only active if development is on/off implDev: { //custom settings for development }, impProd: { //custom settings for production } }"},"docs/v1/ssr":{"titles":{"how-to-use-the-ssr":"How to use the SSR?","global-object":"Global Object","global-methods":"Global Methods","echo":"Echo","sending-the-controllers-of-the-page":"Sending the controllers of the page","global-variable-in-every-file-not-just-ssr-blocks":"Global variable in every file (not just SSR blocks)","model":"Model","component":"Component","default-values":"Default values","page-placeholders-data":"Page Placeholders Data","small-placeholder":"Small Placeholder","define-data":"Define data","add-page-inside-a-page":"Add Page Inside A Page","separate-code-file":"Separate Code File","enforce-js":"Enforce JS"},"text":"Basically, every SSR block (page, model, component) can use EJS and Razor-like rendering ğŸ“‹ @*Simple Comment - this is who to write SSR block *@ &lt;% let i = 0 // script block %&gt; @{ let i++ } @*This is how to print escaped text*@ Count EJS: &lt;%:i%&gt; Count Razor: @:i @*This is how to write literal HTML*@ &lt;%= &quot;&lt;p&gt;Text ejs&lt;/p&gt;&quot; %&gt; @(&quot;&lt;p&gt;Text Razor&lt;/p&gt;&quot;) in each SSR block, these variables are global Response - TinyHttp response object Request - TinyHttp request object Post - null if the method isnâ€™t a post Query - map of the query string Session - Only works if the session enable (in the settings session time bigger than 0) Files - formidable files Cookies - map of the cookie data (setting and removing will affect the cookies) PageVar - public variable to all the SSR blocks in the request GlobalVar - public variable to all the SSR blocks in each SSR block, these methods are global include(path, object: extends page object) - for include another SSR block - page or component transfer(path, preserveForm: boolean - send the form to another page, object: extends page object) - for transfer to another page without redirect echo - template function for writing escaped HTML write - writing HTML writeSafe - writing escaped HTML setResponse - replaceing every HTML that commit to print Echo is a template function for writing safe HTML without XSS security risk ğŸ“‹ echo `&lt;p&gt;User name is: ${Post.name}&lt;/p&gt;` This will print: ğŸ“‹ &lt;p&gt;User name is: &amp;#73;&amp;#100;&amp;#111;&lt;/p&gt; There is a â€˜pageâ€™ variable that contains all the variables and methods above. This is useful when you want to send all the page controllers to a function at once. __dirname - the current folder (although it is a model, eas-framework create that for easy use) __filename - the current filename (although it is a model, eas-framework create that for easy use) Model is a template with placeholders to use by a page. Use can use nested models as well. For example: www/site-model/site.mode ğŸ“‹ &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;:title/&gt;&lt;/title&gt; &lt;:head/&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;My First WebSite&lt;/p&gt; &lt;div&gt; &lt;Link folder=&quot;./&quot; to=&quot;/&quot;&gt;Home&lt;/Link&gt; &lt;Link folder=&quot;./&quot; to=&quot;/about&quot;&gt;About&lt;/Link&gt; &lt;Link folder=&quot;./&quot; to=&quot;/contact&quot;&gt;Contact&lt;/Link&gt; &lt;/div&gt; &lt;:body/&gt; &lt;/body&gt; &lt;/html&gt; www/site-model/Link.inte ğŸ“‹ &lt;style&gt; .link-navbar { color:rgb(44, 117, 185); font-weight: bold; } &lt;/style&gt; &lt;a href=&quot;~to&quot; class=&quot;link-navbar&quot;&gt; &lt;:reader/&gt; &lt;/a&gt; All content of script/style tags will be written only once in separate script and style files. You can prevent this if you need SSR inside the script/style tag with the â€˜serverâ€™ attribute. You can add default values in this form ğŸ“‹ @default(value)[prop1, prop2...] @default(value2)[prop3] For Example ğŸ“‹ @default(/Home)[to] &lt;a href=&quot;~to&quot; class=&quot;link-navbar&quot;&gt; &lt;:reader/&gt; &lt;/a&gt; www/index.page ğŸ“‹ &lt;@model&gt;/site-model/site&lt;/@model&gt; &lt;@body/&gt; Hello Home Page www/about.page ğŸ“‹ &lt;@model&gt;/site-model/site&lt;/@model&gt; &lt;@body/&gt; Hello About Page @{ export function printEmail(email){ write(`&lt;p&gt;You can concat me at ${email}&lt;/p&gt;`) } } There is a better way to write data of small placeholders. You can use â€˜Page Baseâ€™ ğŸ“‹ @[title=Home model=&quot;/site-model/site&quot;] This can alow be good if you want to save a placeholder between models. If you havenâ€™t used the placeholder but you want it to stay in the current model /user-model/user ğŸ“‹ @[title=inherit header=inherit model=&quot;/site-model/site&quot;] If you have pieces of code that repeat many times inside your code. For example path to a component or some attribute, you can define a small placeholder inside your page/model (not working with component) ğŸ“‹ @define(&#x27;site&#x27;, &#x27;/site-model/component/&#x27;) &lt;NavButton folder=&quot;:site:&quot;&gt;Very cool!&lt;/NavButton&gt; The way â€˜defineâ€™ works is: checking first if a value exists on-page if not checking the model and so onâ€¦ www/contact.page ğŸ“‹ &lt;page form=&quot;./about&quot;/&gt; &lt;p&gt;You can concat me at example@email.com&lt;/p&gt; All the examples below will work the same with components You can also add page programmatically - this is done in runtime - slower ğŸ“‹ @include(&quot;./about.page&quot;) &lt;p&gt;You can concat me at example@email.com&lt;/p&gt; If your page export things, you can get them like that ğŸ“‹ @{ include {printEmail} from &#x27;./about.page&#x27; //or const {printEmail} = await include(&#x27;./about.page&#x27;) } @printEmail(&quot;example@email.com&quot;) You can separate the server-side code to a different file that will connect to a page/model/component by using the â€˜filecodeâ€™ placeholder My Page: WWW/About.page ğŸ“‹ @[codeFile=inherit] The inherit will replace by â€˜WWW/About.page.jsâ€™ or â€˜WWW/About.page.tsâ€™ (if TypeScript enabled) You can alow specify exactly the file ğŸ“‹ @[codeFile=&quot;./About.page.ts&quot;] If TypeScript is enabled you can enforce JavaScript by adding â€˜lang=jsâ€™ ğŸ“‹ @[codeFile=inherit lang=js]"},"docs/v1/mpc":{"titles":{"what-is-eas-framework":"What is EAS-Framework?","examples":"Examples","folders":"Folders","components":"Components","nested":"Nested","models":"Models","special-component-attributes":"Special component attributes","example":"Example"},"text":"EAS stands for embedded active server. This is an SSR (server-side rendering) for Node.JS. Its basic concept is page-model-component, a bit similar to asp. model example: www/Site.mode ğŸ“‹ &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;title&gt;&lt;:title/&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;:body/&gt; &lt;/body&gt; &lt;/html&gt; component example: www/ColorButton.inte (component name must be capitalize) ğŸ“‹ @default(blue)[color] &lt;button style=&quot;background-color:~color&quot;&gt; &lt;:reader/&gt; &lt;/button&gt; page example: www/index.page ğŸ“‹ @[model=&#x27;./Site&#x27; title=&#x27;This is Home Page&#x27;] &lt;@body/&gt; &lt;p&gt;This is a big placeholder&lt;/p&gt; &lt;ColorButton folder=&quot;./&quot;&gt;Blue Button&lt;/ColorButton&gt; &lt;ColorButton folder=&quot;./&quot; color=&quot;red&quot;&gt;Red Button&lt;/ColorButton&gt; @{ if(!Cookies.counter) Cookies.counter = 0 Cookies.counter++ } &lt;p&gt;Counter: @Cookies.counter&lt;/p&gt; All those folders must be on the root folder If exists contains components that doesnâ€™t need a â€˜folderâ€™ attribute ğŸ“‹ &lt;ColorButton&gt;Blue Button&lt;/ColorButton&gt; You can do nested components like that: ğŸ“‹ &lt;Colors:Button&gt;Blue Button&lt;/Colors:Button&gt; Colors is the folder and Button is the component file If exists contains models that doesnâ€™t need a relative or absolute path ğŸ“‹ @[model=Site] importSource - The file that imported this component importSourceDirectory - The directory of the file that imported this component If WWW/docs/search.page import Components/TitleIt.inte Then importSource will be WWW/docs/search.page - relative to the website directory"},"docs/v1/record-component":{"titles":{"record":"Record","options":"Options"},"text":"A way to store static html content ğŸ“‹ &lt;record&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; Some text &lt;/record&gt; This it will save in a map where the key is the request-path and the value is the html If you have multiple record on file, it will sum up ğŸ“‹ type recordMap = {[request_path: string]: string} name - the full path to the save location, default is records/record.serv link - the key in the map, default is request-path"},"docs/v1/client-ts":{"titles":{"client-type-script":"Client TypeScript","ssr-block":"SSR Block","as-static-file":"As Static File","with-compile-runtime":"With Compile Runtime"},"text":"You can use TypeScript freely on any SSR block &amp; as separated file When you import TypeScript it automatically transpile into regular JavaScript ğŸ“‹ &lt;script lang=ts&gt; let name: string; while(!name){ name = prompt(&#x27;Enter Name&#x27;); } &lt;/script&gt; WWW/scripts/getName.ts ğŸ“‹ let name: string; while(!name){ name = prompt(&#x27;Enter Name&#x27;); } WWW/name-to-db.page ğŸ“‹ &lt;script src=&quot;/scripts/getName.ts&quot;&gt;&lt;/script&gt; ğŸ“‹ @compile{ script(&#x27;/scripts/getName.ts&#x27;); }"},"docs/v1/client-scope":{"titles":{"scoped-script-style":"Scoped Script/Style","bundling":"Bundling","only-in-page-script-style":"Only in page script/style"},"text":"All content inside all script/style tags is bundled into js/css files and imported automatically to the page - meanings any SSR in this tags wanâ€™t work. If you want to prevent that, for example, you need SSR inside the script tag then you can add the â€˜serverâ€™ attribute. Same appends to style tags ğŸ“‹ &lt;script server&gt; const preventFetch = @isFetch &lt;/script&gt; If you have script/style with a changes that depends on the file you need to and the â€˜pageâ€™ attribute This will make sure that script and style will be scoped to the page. ğŸ“‹ &lt;script page&gt; const name = &quot;:name:&quot;; &lt;/script&gt; â€˜:name:â€™ is a â€˜defineâ€™ value"},"docs/v1/ssr-compile":{"titles":{"compile-run-time":"Compile RunTime","methods":"Methods","define":"define","script":"script","style":"style","variables":"Variables","store":"store","page-filename":"page__filename","page-dirname":"page__dirname","localpath-the-request-path":"__localpath - the request-path","filename":"__filename","dirname":"__dirname","only-on-components":"Only on components","attributes":"attributes"},"text":"Instead of running everything every request, you can run script on compile time! ğŸ“‹ @compile { define(&#x27;create&#x27;, new Date().toLocaleString()); } &lt;p&gt;Page Created: :create:&lt;/p&gt; Use the define feature ğŸ“‹ function define(key: string, value: string) Add script file to the head tag (only if not already exists) ğŸ“‹ function script(path: string, attributes: {[key: string]: string}) Add style file to the head tag (only if not already exists) ğŸ“‹ function script(path: string, attributes: {[key: string]: string}) The â€˜storeâ€™ variable will be available for all the compile block in the page. Regular variable will be only available in same ssr file, everything inside â€˜storeâ€™ variable will be available through all page ğŸ“‹ @compile { store.counter++; } Full path to page Full path to page directory Same as â€˜page__filenameâ€™ but relative to the website folder without the file extension Full path to this file Full path to this directory An â€˜attributesâ€™ map for then attributes in the component. The â€˜readerâ€™ key if for the html inside of the tag ğŸ“‹ var attributes: {[key: string]: string | true}"},"docs/v1/markdown-component":{"titles":{"markdown":"Markdown","how-to-use":"How to use","options":"Options","linkify":"linkify","breaks":"breaks","typographer":"typographer","hljs-class":"hljs-class","theme":"theme","code-theme":"code-theme","header-link":"header-link","attrs":"attrs","copy-code":"copy-code"},"text":"Easy way to use markdown inside an SSR block. Syntax Highlighting build in! Simply add the markdown tag ğŸ“‹ &lt;markdown&gt; # Hello World * Item in list &lt;/markdown&gt; Type: boolean Default: false Uses linkify-it Type: boolean Default: true Convert â€˜\\nâ€™ in paragraphs into &lt;â€br&gt; Type: boolean Default: true Enable some language-neutral replacement * quotes beautification Type: boolean Default: true If false then it will prevent adding â€˜hljsâ€™ class (the code background) Enum: â€˜noneâ€™ | â€˜darkâ€™ | â€˜lightâ€™ | â€˜autoâ€™ Default: 'auto Enum: one of highlight.js themes Default: â€˜atom-oneâ€™ If you wanâ€™t a theme that automatically change base of the user preference (dark/light), you can do it like that: ğŸ“‹ &lt;markdown code-theme=&quot;qtcreator-light|qtcreator-dark&quot;&gt; Type: boolean Default: true Make header as links markdown-it-anchor Type: boolean Default: true Easy use of abbr element markdown-it-abbr Type: string Default: â€˜ğŸ“‹â€™ HTML to show as the copy-code button Full documentation at the repository of markdown-it"},"docs/v1/search-component":{"titles":{"search":"Search","options":"Options","using-the-search":"Using the search"},"text":"Similar to record but for search purposes This will extract titles from the texts ğŸ“‹ type searchMap = {[request-path]: { titles: {[key: objectId]: string} text: string }} name - the full path to the save location, default is records/search.serv link - the key in the map, default is request-path match - query selector for ids, default is â€˜h1[id]â€¦h6[id]â€™ You can search in a â€˜search-recordâ€™ with the build in â€˜SearchRecordâ€™ class ğŸ“‹ import {SearchRecord} from &#x27;@eas-framework/server&#x27; const textSearch = new SearchRecord(&#x27;records/search.serv&#x27;) await textSearch.load() export function queryText(query){ return textSearch.search(query) } You can use then with SSR block ğŸ“‹ @{ import {queryText} from &#x27;./searchFile.serv.js&#x27; } @(const {text, url} of queryText(Query.q ?? &#x27;new&#x27;)){ &lt;a href=&quot;@url&quot;&gt;@:text&lt;/a&gt; }"},"docs/v1/binding-connect":{"titles":{"binding-connect":"Binding - Connect"},"text":"There is another method to retrieve data from the server - with JavaScript on the client-side. I will show the best practices of doing so. Forms are very useful and convenient but do not fit good to events from the client side. That way we have to â€˜connectâ€™ tag. ğŸ“‹ @{ async function userMessage(text, userId){ try { return await sendMessageToUser(text, userId, Session.userId) } catch { return {error: &quot;Can&#x27;t send message - make sure user exists&quot;} } } } &lt;connect sendTo=&quot;userMessage&quot; name=&quot;sendMessageServer&quot; validator=&quot;1:200,integer&quot;/&gt; &lt;input type=&quot;number&quot; id=&quot;userId&quot; placeholder=&quot;User Id&quot;/&gt; &lt;textarea id=&quot;message&quot; name=&quot;message&quot; placeholder=&quot;Enter your message&quot;&gt;&lt;/textarea&gt; &lt;button onclick=&quot;sendMessage()&quot;&gt;Send Message&lt;/button&gt; &lt;script&gt; const $ = x =&gt; document.querySelector(x); async function sendMessage(){ const sent = await sendMessageServer($(&#x27;#userId&#x27;).value, $(&#x27;#message&#x27;).value) if(sent.error) return alert(&#x27;Error: &#x27; + sent.error); alert(&#x27;Success: &#x27; + sent); } &lt;/script&gt; The response can be any type (JSON, Number, Booleanâ€¦) Validation Error You can also use â€˜noValidâ€™ and â€˜messageâ€™ ğŸ“‹ &lt;connect sendTo=&quot;userMessage&quot; name=&quot;sendMessageServer&quot; validator=&quot;1:200,integer&quot; noValid=&quot;() =&gt; ({error: &#x27;fields not valid&#x27;})&quot;/&gt; ğŸ“‹ &lt;connect sendTo=&quot;userMessage&quot; name=&quot;sendMessageServer&quot; validator=&quot;1:200,integer&quot; message=&quot;Enter a valid userId and make sure the message is between 1 to 200 characters&quot;/&gt;"},"docs/v1/server-files":{"titles":{"how-to-add-a-server-script":"How to add a server script","import-on-start":"Import on start"},"text":"Files that end with â€˜.serv.jsâ€™ or â€˜.serv.tsâ€™ (When TypeScript enabled) will not be visible as normal text files and can only be imported by the server. If you need file to be imported as the server start you can add the path to the Settings file Setting file will search the file in the WWW folder ğŸ“‹ general: { importOnLoad: [&quot;OnStart.serv.ts&quot;] } The server will try to call function name â€˜StartServerâ€™ ğŸ“‹ function StartServer(app: TinyApp, { server: http.server, close: () =&gt; void }, Settings: ExportSettings)"}}